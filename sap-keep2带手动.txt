// ç¯å¢ƒå˜é‡é…ç½®(å¿…å¡«)
let email = "antidanatoritania@gmail.com";      // SAPç™»å½•é‚®ç®±,ç›´æ¥å¡«å†™æˆ–è®¾ç½®ç¯å¢ƒå˜é‡ï¼Œå˜é‡åï¼šEMAIL
let password = "Hh090909";   // SAPç™»å½•å¯†ç ,ç›´æ¥å¡«å†™æˆ–è®¾ç½®ç¯å¢ƒå˜é‡ï¼Œå˜é‡åï¼šPASSWORD

// ç¦»çº¿é‡å¯é€šçŸ¥ Telegramé…ç½®(å¯é€‰)
let CHAT_ID = "";    // TelegramèŠå¤©CHAT_ID,ç›´æ¥å¡«å†™æˆ–è®¾ç½®ç¯å¢ƒå˜é‡ï¼Œå˜é‡åï¼šCHAT_ID
let BOT_TOKEN = "";  // Telegramæœºå™¨äººTOKEN,ç›´æ¥å¡«å†™æˆ–è®¾ç½®ç¯å¢ƒå˜é‡ï¼Œå˜é‡åï¼šBOT_TOKEN

// åº”ç”¨é…ç½® URLå’Œåº”ç”¨åç§°é…ç½®(å¿…å¡«)
const MONITORED_APPS = [ // æ ¼å¼: {url: "åº”ç”¨URL", name: "åº”ç”¨åç§°"}
  {url: "https://sggudgxx.cfapps.ap21.hana.ondemand.com", name: "s1"},  
  {url: "https://us0.cfapps.us10-001.hana.ondemand.com", name: "us0"}
];

// åŒºåŸŸå›ºå®šå¸¸é‡(æ— éœ€æ›´æ”¹)
const REGIONS = {
  US: {
    CF_API: "https://api.cf.us10-001.hana.ondemand.com",
    UAA_URL: "https://uaa.cf.us10-001.hana.ondemand.com",
    DOMAIN_PATTERN: /\.us10(-001)?\.hana\.ondemand\.com$/
  },
  AP: {
    CF_API: "https://api.cf.ap21.hana.ondemand.com",
    UAA_URL: "https://uaa.cf.ap21.hana.ondemand.com",
    DOMAIN_PATTERN: /\.ap21\.hana\.ondemand\.com$/
  }
};

// å·¥å…·å‡½æ•°
const pad = n => String(n).padStart(2, "0");
const sleep = ms => new Promise(r => setTimeout(r, ms));
const json = (o, c = 200) => new Response(JSON.stringify(o), {
  status: c,
  headers: { "content-type": "application/json" }
});

// Telegram æ¶ˆæ¯å‘é€
async function sendTelegramMessage(message) {
  // å¦‚æœæ²¡æœ‰é…ç½® Telegram å‚æ•°ï¼Œåˆ™å¿½ç•¥
  if (!CHAT_ID || !BOT_TOKEN || CHAT_ID === "your-chat-id" || BOT_TOKEN === "your-telegram-bot-token") {
    console.log("[telegram] Telegram æœªé…ç½®ï¼Œè·³è¿‡å‘é€æ¶ˆæ¯");
    return;
  }

  try {
    const telegramUrl = `https://api.telegram.org/bot${BOT_TOKEN}/sendMessage`;
    const response = await fetch(telegramUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        chat_id: CHAT_ID,
        text: message,
        parse_mode: "Markdown"
      })
    });

    const result = await response.json();
    if (!response.ok) {
      console.error(`[telegram-error] å‘é€æ¶ˆæ¯å¤±è´¥: ${result.description}`);
    } else {
      console.log("[telegram] æ¶ˆæ¯å‘é€æˆåŠŸ");
    }
    return result;
  } catch (error) {
    console.error(`[telegram-error] å‘é€æ¶ˆæ¯æ—¶å‡ºé”™: ${error.message}`);
  }
}

// è½¬æ¢æˆä¸Šæµ·æ—¶é—´
function formatShanghaiTime(date) {
  const utcTime = date.getTime() + (date.getTimezoneOffset() * 60000);
  const shanghaiTime = new Date(utcTime + (8 * 60 * 60 * 1000));
  
  return shanghaiTime.getFullYear() + '-' + 
         String(shanghaiTime.getMonth() + 1).padStart(2, '0') + '-' + 
         String(shanghaiTime.getDate()).padStart(2, '0') + ' ' +
         String(shanghaiTime.getHours()).padStart(2, '0') + ':' +
         String(shanghaiTime.getMinutes()).padStart(2, '0');
}

// æ ¹æ®URLè¯†åˆ«åŒºåŸŸ
function detectRegionFromUrl(url) {
  for (const [regionCode, regionConfig] of Object.entries(REGIONS)) {
    if (regionConfig.DOMAIN_PATTERN.test(url)) {
      return regionCode;
    }
  }
  return null;
}

// CF API äº¤äº’å‡½æ•°
async function cfGET(url, token) {
  const response = await fetch(url, {
    headers: { authorization: `Bearer ${token}` }
  });
  const text = await response.text();
  if (!response.ok) {
    throw new Error(`CF GET ${response.status} ${url}: ${text.slice(0, 200)}`);
  }
  return text ? JSON.parse(text) : {};
}

async function cfPOST(url, token, payload) {
  const response = await fetch(url, {
    method: "POST",
    headers: {
      authorization: `Bearer ${token}`,
      "content-type": "application/json"
    },
    body: payload ? JSON.stringify(payload) : null
  });
  const text = await response.text();
  if (!response.ok) {
    throw new Error(`CF POST ${response.status} ${url}: ${text.slice(0, 200)}`);
  }
  return text ? JSON.parse(text) : {};
}

// è®¤è¯å‡½æ•°
async function getUAAToken(email, password, uaaUrl) {
  try {
    console.log(`[auth] å°è¯•è®¤è¯: ${email} @ ${uaaUrl}`);
    
    const authHeader = "Basic " + btoa("cf:");
    const body = new URLSearchParams();
    body.set("grant_type", "password");
    body.set("username", email);
    body.set("password", password);
    body.set("response_type", "token");

    const response = await fetch(`${uaaUrl}/oauth/token`, {
      method: "POST",
      headers: {
        authorization: authHeader,
        "content-type": "application/x-www-form-urlencoded"
      },
      body: body
    });

    const text = await response.text();
    console.log(`[auth] å“åº”çŠ¶æ€: ${response.status}, å“åº”æ–‡æœ¬: ${text.substring(0, 200)}...`);
    
    if (!response.ok) {
      throw new Error(`UAA token error: ${response.status} ${text}`);
    }
    
    const result = JSON.parse(text);
    return result.access_token;
  } catch (error) {
    console.error(`[auth-error] è®¤è¯å¤±è´¥: ${error.message}`);
    throw error;
  }
}

// åº”ç”¨ä¿¡æ¯è·å–å‡½æ•° 
async function getAppGuidByName(apiUrl, token, appName) {
  const result = await cfGET(`${apiUrl}/v3/apps?names=${encodeURIComponent(appName)}`, token);
  if (result.resources && result.resources.length > 0) {
    return result.resources[0].guid;
  }
  throw new Error(`Application ${appName} not found`);
}

// åº”ç”¨çŠ¶æ€å‡½æ•°
async function getAppState(apiUrl, token, appGuid) {
  const result = await cfGET(`${apiUrl}/v3/apps/${appGuid}`, token);
  return result?.state || "UNKNOWN";
}

async function getWebProcessGuid(apiUrl, token, appGuid) {
  const result = await cfGET(`${apiUrl}/v3/apps/${appGuid}/processes`, token);
  const webProcess = result?.resources?.find(p => p?.type === "web") || result?.resources?.[0];
  if (!webProcess) {
    throw new Error("No web process found on app");
  }
  return webProcess.guid;
}

async function getProcessStats(apiUrl, token, processGuid) {
  return cfGET(`${apiUrl}/v3/processes/${processGuid}/stats`, token);
}

// åº”ç”¨çŠ¶æ€ç­‰å¾…å‡½æ•° 
async function waitAppStarted(apiUrl, token, appGuid) {
  let delay = 2000;
  let state = "";
  
  for (let i = 0; i < 8; i++) {
    await sleep(delay);
    state = await getAppState(apiUrl, token, appGuid);
    console.log(`[app-state-check] attempt ${i + 1}: ${state}`);
    
    if (state === "STARTED") break;
    delay = Math.min(delay * 1.6, 15000);
  }
  
  if (state !== "STARTED") {
    throw new Error(`App not STARTED in time, final state=${state}`);
  }
}

async function waitProcessInstancesRunning(apiUrl, token, processGuid) {
  let delay = 2000;
  
  for (let i = 0; i < 10; i++) {
    const stats = await getProcessStats(apiUrl, token, processGuid);
    const instances = stats?.resources || [];
    const states = instances.map(it => it?.state);
    
    console.log(`[proc-stats] attempt ${i + 1}: ${states.join(",") || "no-instances"}`);
    
    if (states.some(s => s === "RUNNING")) return;
    
    await sleep(delay);
    delay = Math.min(delay * 1.6, 15000);
  }
  
  throw new Error("Process instances not RUNNING in time");
}

//  APP URL æ£€æŸ¥å‡½æ•° 
async function checkAppUrl(appUrl) {
  try {
    const response = await fetch(appUrl, {
      method: "GET",
      signal: AbortSignal.timeout(30000)
    });
    console.log(`[app-check] ${appUrl} status: ${response.status}`);
    return response.status === 200;
  } catch (error) {
    console.log(`[app-check] ${appUrl} error: ${error.message}`);
    return false;
  }
}

// æ‰‹åŠ¨é‡å¯å•ä¸ªåº”ç”¨ï¼ˆæ–°å¢ï¼šæ”¯æŒå•ä¸ªåº”ç”¨é‡å¯ï¼Œä¸ºæ‰¹é‡é‡å¯åšåŸºç¡€ï¼‰
async function restartSingleApp(appConfig) {
  const { url, name } = appConfig;
  console.log(`[restart] å¼€å§‹æ‰‹åŠ¨é‡å¯åº”ç”¨: ${name} (${url})`);

  // 1. ç¡®å®šåº”ç”¨åŒºåŸŸ
  const detectedRegion = detectRegionFromUrl(url);
  if (!detectedRegion || !REGIONS[detectedRegion]) {
    throw new Error(`æ— æ³•ç¡®å®šåº”ç”¨ ${name} çš„åŒºåŸŸï¼ŒURL: ${url}`);
  }
  const regionConfig = REGIONS[detectedRegion];

  try {
    // 2. è·å–è®¤è¯Token
    const token = await getUAAToken(email, password, regionConfig.UAA_URL);
    
    // 3. è·å–åº”ç”¨GUID
    const appGuid = await getAppGuidByName(regionConfig.CF_API, token, name);
    console.log(`[restart] åº”ç”¨ ${name} çš„GUID: ${appGuid}`);
    
    // 4. è·å–Webè¿›ç¨‹GUID
    const processGuid = await getWebProcessGuid(regionConfig.CF_API, token, appGuid);
    
    // 5. å…ˆåœæ­¢åº”ç”¨ï¼ˆç¡®ä¿å®Œå…¨é‡å¯ï¼‰
    console.log(`[restart] æ­£åœ¨åœæ­¢åº”ç”¨ ${name}...`);
    await cfPOST(`${regionConfig.CF_API}/v3/apps/${appGuid}/actions/stop`, token);
    await sleep(3000); // ç­‰å¾…åœæ­¢å®Œæˆ
    
    // 6. å¯åŠ¨åº”ç”¨
    console.log(`[restart] æ­£åœ¨å¯åŠ¨åº”ç”¨ ${name}...`);
    await cfPOST(`${regionConfig.CF_API}/v3/apps/${appGuid}/actions/start`, token);
    
    // 7. ç­‰å¾…åº”ç”¨å¯åŠ¨å®Œæˆ
    await waitAppStarted(regionConfig.CF_API, token, appGuid);
    await waitProcessInstancesRunning(regionConfig.CF_API, token, processGuid);
    
    // 8. éªŒè¯å¯åŠ¨ç»“æœ
    const isHealthy = await checkAppUrl(url);
    if (isHealthy) {
      const successMsg = `âœ… *åº”ç”¨æ‰‹åŠ¨é‡å¯æˆåŠŸ*\nåº”ç”¨åç§°: ${name}\nåº”ç”¨URL: ${url}\næ—¶é—´: ${formatShanghaiTime(new Date())}`;
      await sendTelegramMessage(successMsg);
      console.log(`[restart] åº”ç”¨ ${name} é‡å¯æˆåŠŸ`);
      return { app: name, status: "restart_success", url: url };
    } else {
      const failMsg = `âŒ *åº”ç”¨æ‰‹åŠ¨é‡å¯å¤±è´¥*\nåº”ç”¨åç§°: ${name}\nåº”ç”¨URL: ${url}\næ—¶é—´: ${formatShanghaiTime(new Date())}\nåŸå› : é‡å¯åURLè®¿é—®å¼‚å¸¸`;
      await sendTelegramMessage(failMsg);
      throw new Error(`åº”ç”¨ ${name} é‡å¯åURLè®¿é—®å¼‚å¸¸`);
    }
  } catch (error) {
    const errorMsg = `âŒ *åº”ç”¨æ‰‹åŠ¨é‡å¯å‡ºé”™*\nåº”ç”¨åç§°: ${name}\nåº”ç”¨URL: ${url}\næ—¶é—´: ${formatShanghaiTime(new Date())}\né”™è¯¯: ${error.message}`;
    await sendTelegramMessage(errorMsg);
    console.error(`[restart-error] åº”ç”¨ ${name} é‡å¯å¤±è´¥: ${error.message}`);
    throw error;
  }
}

// æ‰‹åŠ¨é‡å¯æ‰€æœ‰åº”ç”¨ï¼ˆæ–°å¢ï¼šæ‰¹é‡é‡å¯æ‰€æœ‰ç›‘æ§åº”ç”¨ï¼‰
async function restartAllApps() {
  console.log(`[restart-all] å¼€å§‹æ‰‹åŠ¨é‡å¯æ‰€æœ‰ç›‘æ§åº”ç”¨ï¼Œå…± ${MONITORED_APPS.length} ä¸ª`);
  const results = [];

  // é€ä¸ªé‡å¯ï¼ˆé¿å…å¹¶å‘å¯¼è‡´çš„è®¤è¯/APIå‹åŠ›ï¼‰
  for (const app of MONITORED_APPS) {
    try {
      const result = await restartSingleApp(app);
      results.push(result);
    } catch (error) {
      results.push({
        app: app.name,
        status: "restart_failed",
        url: app.url,
        error: error.message
      });
    }
    await sleep(2000); // æ¯ä¸ªåº”ç”¨é‡å¯åé—´éš”2ç§’ï¼Œé™ä½APIè°ƒç”¨é¢‘ç‡
  }

  // å‘é€æ‰¹é‡é‡å¯æ±‡æ€»é€šçŸ¥
  const successCount = results.filter(r => r.status === "restart_success").length;
  const failCount = results.filter(r => r.status === "restart_failed").length;
  const summaryMsg = `ğŸ“Š *æ‰€æœ‰åº”ç”¨æ‰‹åŠ¨é‡å¯æ±‡æ€»*\næ—¶é—´: ${formatShanghaiTime(new Date())}\næ€»æ•°é‡: ${MONITORED_APPS.length}\næˆåŠŸ: ${successCount}\nå¤±è´¥: ${failCount}\n\nå¤±è´¥åº”ç”¨: ${failCount > 0 ? results.filter(r => r.status === "restart_failed").map(r => r.app).join(", ") : "æ— "}`;
  await sendTelegramMessage(summaryMsg);

  console.log(`[restart-all] æ‰€æœ‰åº”ç”¨é‡å¯å®Œæˆï¼ŒæˆåŠŸ: ${successCount}ï¼Œå¤±è´¥: ${failCount}`);
  return results;
}

// é¦–é¡µï¼ˆä¿®æ”¹ï¼šæ·»åŠ æ‰‹åŠ¨é‡å¯æŒ‰é’® + ä¼˜åŒ–æŒ‰é’®æ ·å¼ï¼‰
function generateStatusPage(apps) {
  // è·å–å½“å‰æ—¶é—´å¹¶è½¬æ¢ä¸ºä¸Šæµ·æ—¶é—´ï¼ˆåŒ—äº¬æ—¶é—´ï¼‰
  const now = new Date();
  const utcTime = now.getTime() + (now.getTimezoneOffset() * 60000);
  const shanghaiTime = new Date(utcTime + (8 * 60 * 60 * 1000));
  
  const formattedDate = shanghaiTime.getFullYear() + '-' + 
                      String(shanghaiTime.getMonth() + 1).padStart(2, '0') + '-' + 
                      String(shanghaiTime.getDate()).padStart(2, '0') + ' ' +
                      String(shanghaiTime.getHours()).padStart(2, '0') + ':' +
                      String(shanghaiTime.getMinutes()).padStart(2, '0');
  
  const statusCards = apps.map(app => {
    const statusClass = app.healthy ? 'status-up' : 'status-down';
    const statusText = app.healthy ? 'è¿è¡Œä¸­' : 'å·²åœæ­¢';
    const regionName = app.region === 'US' ? 'ç¾å›½' : app.region === 'AP' ? 'æ–°åŠ å¡' : 'æœªçŸ¥';
    
    return `
      <div class="status-card ${statusClass}">
        <div class="card-header">
          <h3>${app.app}</h3>
          <span class="status-indicator ${statusClass}">${statusText}</span>
        </div>
        <div class="card-body">
          <p><strong>åŒºåŸŸ:</strong> ${regionName}</p>
          <p><strong>URL:</strong> <a href="${app.url}" target="_blank">${app.url}</a></p>
        </div>
      </div>
    `;
  }).join('');
  
  return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SAP Cloud åº”ç”¨çŠ¶æ€ç›‘æ§</title>
  <style>
    :root {
      --up-color: #4CAF50;
      --down-color: #F44336;
      --card-bg: #ffffff;
      --bg-color: #f5f5f5;
      --text-color: #333333;
      --border-radius: 8px;
      --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --btn-refresh-bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --btn-restart-bg: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background-color: var(--bg-color);
      color: var(--text-color);
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      text-align: center;
    }
    
    header {
      text-align: center;
      padding: 30px 0;
      background: #667eea;
      color: white;
      border-radius: var(--border-radius);
      margin-bottom: 30px;
      box-shadow: var(--box-shadow);
    }
    
    h1 {
      margin: 0;
      font-size: 2.5rem;
    }
    
    .subtitle {
      font-size: 1.2rem;
      opacity: 0.9;
      margin-top: 10px;
    }
    
    .status-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 20px;
      margin: 0 auto;
      max-width: 800px;
      width: 100%;
    }
    
    .status-card {
      background: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--box-shadow);
      overflow: hidden;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      margin: 0 auto;
    }
    
    .status-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }
    
    .card-header {
      padding: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid #eee;
    }
    
    .card-header h3 {
      margin: 0;
      font-size: 1.5rem;
    }
    
    .status-indicator {
      padding: 5px 15px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 0.9rem;
    }
    
    .status-up {
      background-color: rgba(76, 175, 80, 0.1);
      color: var(--up-color);
    }
    
    .status-down {
      background-color: rgba(244, 67, 54, 0.1);
      color: var(--down-color);
    }
    
    .card-body {
      padding: 20px;
    }
    
    .card-body p {
      margin: 10px 0;
    }
    
    .card-body a {
      color: #1976D2;
      text-decoration: none;
    }
    
    .card-body a:hover {
      text-decoration: underline;
    }
    
    .last-updated {
      text-align: center;
      color: #666;
      font-size: 0.9rem;
      margin-top: 20px;
    }
    
    .controls {
      text-align: center;
      margin: 30px 0;
      display: flex;
      justify-content: center;
      gap: 15px; /* æŒ‰é’®é—´è· */
      flex-wrap: wrap; /* è‡ªé€‚åº”æ¢è¡Œ */
    }
    
    .btn {
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 1rem;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: opacity 0.3s ease, transform 0.2s ease;
      font-weight: 500;
    }
    
    .btn:hover {
      opacity: 0.9;
      transform: translateY(-2px);
    }
    
    .btn:active {
      transform: translateY(0);
    }
    
    .btn-refresh {
      background: var(--btn-refresh-bg);
    }
    
    .btn-restart {
      background: var(--btn-restart-bg);
    }
    
    /* åŠ è½½çŠ¶æ€æ ·å¼ï¼ˆæ–°å¢ï¼šé‡å¯æ—¶æ˜¾ç¤ºåŠ è½½ä¸­ï¼‰ */
    .loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 9999;
      color: white;
      font-size: 1.2rem;
    }
    
    .spinner {
      border: 4px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top: 4px solid white;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-right: 15px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    footer {
      text-align: center;
      padding: 20px;
      color: #666;
      font-size: 0.9rem;
      border-top: 1px solid #eee;
      margin-top: 30px;
    }
    
    .footer-links {
      font-weight: 700;
      font-size: larger;
      margin-top: 10px;
    }
    
    .footer-links a {
      color: #1976D2;
      text-decoration: none;
      margin: 0 10px;
    }
    
    .footer-links a:hover {
      text-decoration: underline;
    }
    
    @media (max-width: 768px) {
      .status-grid {
        grid-template-columns: 1fr;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .controls {
        flex-direction: column;
        align-items: center;
      }
      
      .btn {
        width: 80%;
        margin-bottom: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>SAP Cloud åº”ç”¨ç›‘æ§</h1>
      <div class="subtitle">å®æ—¶ç›‘æ§åº”ç”¨çŠ¶æ€ï¼Œæ”¯æŒæ‰‹åŠ¨é‡å¯</div>
    </header>
    
    <!-- æ“ä½œæŒ‰é’®åŒºï¼ˆä¿®æ”¹ï¼šæ–°å¢æ‰‹åŠ¨é‡å¯æŒ‰é’®ï¼‰ -->
    <div class="controls">
      <button class="btn btn-refresh" onclick="refreshStatus()">åˆ·æ–°çŠ¶æ€</button>
      <button class="btn btn-restart" onclick="manualRestartAllApps()">æ‰‹åŠ¨é‡å¯æ‰€æœ‰åº”ç”¨</button>
    </div>
    
    <!-- åŠ è½½çŠ¶æ€æç¤ºï¼ˆæ–°å¢ï¼šé‡å¯æ—¶æ˜¾ç¤ºï¼‰ -->
    <div id="loading" class="loading" style="display: none;">
      <div class="spinner"></div>
      <div>æ­£åœ¨é‡å¯æ‰€æœ‰åº”ç”¨ï¼Œè¯·ç¨å€™...</div>
    </div>
    
    <div class="status-grid">
      ${statusCards}
    </div>
    
    <div class="last-updated">
      æœ€åæ›´æ–°: ${formattedDate}
    </div>
    
    <footer>
      <p>SAP Cloud å¤šåº”ç”¨è‡ªåŠ¨ä¿æ´»ç³»ç»Ÿ</p>
      <div class="footer-links">
        <a href="https://github.com/eooce/Auto-deploy-sap-and-keepalive" target="_blank">GitHub</a>
        <a href="https://www.youtube.com/@eooce" target="_blank">YouTube</a>
        <a href="https://t.me/eooceu" target="_blank">Telegram Group</a>
      </div>
      <p>&copy; ${new Date().getFullYear()} Auto-SAP. All rights reserved.</p>
    </footer>
  </div>
  
  <script>
    // åˆ·æ–°çŠ¶æ€ï¼ˆåŸæœ‰åŠŸèƒ½ä¿ç•™ï¼‰
    function refreshStatus() {
      location.reload();
    }
    
    // æ‰‹åŠ¨é‡å¯æ‰€æœ‰åº”ç”¨ï¼ˆæ–°å¢ï¼šå‰ç«¯äº¤äº’é€»è¾‘ï¼‰
    async function manualRestartAllApps() {
      // 1. ç¡®è®¤ç”¨æˆ·æ“ä½œï¼ˆé¿å…è¯¯è§¦ï¼‰
      const confirmRestart = confirm("ç¡®å®šè¦æ‰‹åŠ¨é‡å¯æ‰€æœ‰åº”ç”¨å—ï¼Ÿ\\né‡å¯è¿‡ç¨‹ä¸­åº”ç”¨å¯èƒ½ä¼šçŸ­æš‚ä¸å¯ç”¨ï¼Œè¯·ç¡®è®¤åç»§ç»­ï¼");
      if (!confirmRestart) return;
      
      // 2. æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      const loadingEl = document.getElementById("loading");
      loadingEl.style.display = "flex";
      
      try {
        // 3. è°ƒç”¨åç«¯é‡å¯æ¥å£
        const response = await fetch("/restart-all", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          }
        });
        
        const result = await response.json();
        if (result.ok) {
          alert("æ‰€æœ‰åº”ç”¨é‡å¯è¯·æ±‚å·²æäº¤ï¼\\né‡å¯ç»“æœä¼šé€šè¿‡Telegramé€šçŸ¥ï¼Œä¹Ÿå¯åˆ·æ–°é¡µé¢æŸ¥çœ‹æœ€æ–°çŠ¶æ€ã€‚");
        } else {
          alert("é‡å¯è¯·æ±‚æäº¤å¤±è´¥ï¼š" + (result.error || "æœªçŸ¥é”™è¯¯"));
        }
      } catch (error) {
        alert("è°ƒç”¨é‡å¯æ¥å£å‡ºé”™ï¼š" + error.message);
      } finally {
        // 4. éšè—åŠ è½½çŠ¶æ€
        loadingEl.style.display = "none";
      }
    }
  </script>
</body>
</html>
  `;
}

// æ ¸å¿ƒå¯åŠ¨é€»è¾‘ï¼ˆåŸæœ‰åŠŸèƒ½ä¿ç•™ï¼‰
async function ensureAppRunning(appConfig, reason = "unknown") {
  const {url, name, region} = appConfig;
  
  console.log(`[trigger] ${reason} for app ${name} at ${new Date().toISOString()}`);
  
  // ç¬¬ä¸€æ­¥ï¼šæ£€æŸ¥åº”ç”¨URLçŠ¶æ€
  const isAppHealthy = await checkAppUrl(url);
  if (isAppHealthy) {
    console.log(`[decision] ${url} è¿”å›200ï¼Œåº”ç”¨æ­£å¸¸è¿è¡Œï¼Œæ— éœ€å¯åŠ¨`);
    return {app: name, status: "healthy", url: url};
  }
  
  // å‘é€ç¦»çº¿æé†’ï¼ˆä½¿ç”¨ä¸Šæµ·æ—¶é—´ï¼‰
  const now = new Date();
  const formattedTime = formatShanghaiTime(now);
  const offlineMessage = `âš ï¸ *SAPåº”ç”¨ç¦»çº¿æé†’*\n\nåº”ç”¨åç§°: ${name}\nåº”ç”¨URL: ${url}\næ—¶é—´: ${formattedTime}\n\næ­£åœ¨å°è¯•é‡å¯åº”ç”¨...`;
  await sendTelegramMessage(offlineMessage);
  
  console.log(`[decision] ${url} çŠ¶æ€å¼‚å¸¸ï¼Œå¼€å§‹å¯åŠ¨åº”ç”¨`);
  
  // ç¬¬äºŒæ­¥ï¼šç¡®å®šåŒºåŸŸ
  const detectedRegion = region || detectRegionFromUrl(url);
  if (!detectedRegion || !REGIONS[detectedRegion]) {
    throw new Error(`æ— æ³•ç¡®å®šåº”ç”¨ ${name} çš„åŒºåŸŸï¼ŒURL: ${url}`);
  }
  
  const regionConfig = REGIONS[detectedRegion];
  console.log(`[region] åº”ç”¨ ${name} çš„åŒºåŸŸ: ${detectedRegion}`);
  
  // ç¬¬ä¸‰æ­¥ï¼šè·å–CF APIè®¿é—®ä»¤ç‰Œ
  const token = await getUAAToken(email, password, regionConfig.UAA_URL);
  
  // ç¬¬å››æ­¥ï¼šæ ¹æ®åº”ç”¨åç§°è·å–GUID
  const appGuid = await getAppGuidByName(regionConfig.CF_API, token, name);
  console.log(`[app-guid] ${appGuid}`);
  
  // ç¬¬äº”æ­¥ï¼šè·å–è¿›ç¨‹ä¿¡æ¯
  const processGuid = await getWebProcessGuid(regionConfig.CF_API, token, appGuid);
  
  // ç¬¬å…­æ­¥ï¼šæ£€æŸ¥å½“å‰åº”ç”¨çŠ¶æ€
  const appState = await getAppState(regionConfig.CF_API, token, appGuid);
  console.log(`[app-state-before] ${appState}`);
  
  // ç¬¬ä¸ƒæ­¥ï¼šå¯åŠ¨åº”ç”¨ï¼ˆå¦‚æœéœ€è¦ï¼‰
  if (appState !== "STARTED") {
    await cfPOST(`${regionConfig.CF_API}/v3/apps/${appGuid}/actions/start`, token);
    console.log("[action] åº”ç”¨å¯åŠ¨è¯·æ±‚å·²å‘é€");
  }
  
  // ç¬¬å…«æ­¥ï¼šç­‰å¾…åº”ç”¨å¯åŠ¨å®Œæˆ
  await waitAppStarted(regionConfig.CF_API, token, appGuid);
  await waitProcessInstancesRunning(regionConfig.CF_API, token, processGuid);
  
  // ç¬¬ä¹æ­¥ï¼šå†æ¬¡æ£€æŸ¥åº”ç”¨URLç¡®ä¿å¯åŠ¨æˆåŠŸ
  console.log("[verification] éªŒè¯åº”ç”¨æ˜¯å¦æˆåŠŸå¯åŠ¨...");
  await sleep(5000);
  
  const isAppHealthyAfterStart = await checkAppUrl(url);
  if (isAppHealthyAfterStart) {
    console.log("[success] åº”ç”¨å¯åŠ¨æˆåŠŸï¼ŒURLçŠ¶æ€æ­£å¸¸");
    // å‘é€é‡å¯æˆåŠŸæé†’
    const successMessage = `âœ… *SAPåº”ç”¨é‡å¯æˆåŠŸ*\n\nåº”ç”¨åç§°: ${name}\nåº”ç”¨URL: ${url}\næ—¶é—´: ${formatShanghaiTime(new Date())}`;
    await sendTelegramMessage(successMessage);
    return {app: name, status: "started", url: url};
  } else {
    // å‘é€é‡å¯å¤±è´¥æé†’
    const failedMessage = `âŒ *SAPåº”ç”¨é‡å¯å¤±è´¥*\n\nåº”ç”¨åç§°: ${name}\nåº”ç”¨URL: ${url}\næ—¶é—´: ${formatShanghaiTime(new Date())}`;
    await sendTelegramMessage(failedMessage);
    return {app: name, status: "started_but_unhealthy", url: url};
  }
}

//ç›‘æ§æ‰€æœ‰åº”ç”¨ï¼ˆåŸæœ‰åŠŸèƒ½ä¿ç•™ï¼‰
async function monitorAllApps(reason = "unknown") {
  console.log(`[monitor-start] å¼€å§‹ç›‘æ§æ‰€æœ‰åº”ç”¨: ${reason}`);
  const results = [];
  
  for (const app of MONITORED_APPS) {
    try {
      const result = await ensureAppRunning(app, reason);
      results.push(result);
    } catch (error) {
      console.error(`[app-error] å¤„ç†åº”ç”¨ ${app.name} æ—¶å‡ºé”™:`, error.message);
      results.push({app: app.name, status: "error", error: error.message, url: app.url});
    }
    // åœ¨æ¯ä¸ªåº”ç”¨æ£€æŸ¥ä¹‹é—´æ·»åŠ çŸ­æš‚å»¶è¿Ÿ
    await sleep(1000);
  }
  
  console.log(`[monitor-complete] æ‰€æœ‰åº”ç”¨ç›‘æ§å®Œæˆ`);
  return results;
}

export default {
  // HTTP è¯·æ±‚å¤„ç†ï¼ˆä¿®æ”¹ï¼šæ–°å¢ /restart-all æ¥å£ï¼Œæ”¯æŒæ‰‹åŠ¨é‡å¯ï¼‰
  async fetch(request, env, ctx) {
    // ä»ç¯å¢ƒå˜é‡è·å–é‚®ç®±å’Œå¯†ç 
    email = env.EMAIL || email;
    password = env.PASSWORD || password;
    CHAT_ID = env.CHAT_ID || CHAT_ID;
    BOT_TOKEN = env.BOT_TOKEN || BOT_TOKEN;
    
    const url = new URL(request.url);
    
    try {
      // æ ¹è·¯å¾„ - æ˜¾ç¤ºå‰ç«¯é¡µé¢ï¼ˆåŸæœ‰åŠŸèƒ½ä¿ç•™ï¼‰
      if (url.pathname === "/") {
        // è·å–æ‰€æœ‰åº”ç”¨çŠ¶æ€
        const statusResults = [];
        for (const app of MONITORED_APPS) {
          const isHealthy = await checkAppUrl(app.url);
          statusResults.push({
            app: app.name,
            url: app.url,
            healthy: isHealthy,
            region: detectRegionFromUrl(app.url)
          });
        }
        
        // ç”ŸæˆHTMLé¡µé¢
        const html = generateStatusPage(statusResults);
        return new Response(html, {
          headers: { "content-type": "text/html;charset=UTF-8" }
        });
      }
      
      // æ–°å¢ï¼šæ‰‹åŠ¨é‡å¯æ‰€æœ‰åº”ç”¨æ¥å£ï¼ˆä¾›å‰ç«¯è°ƒç”¨ï¼‰
      if (url.pathname === "/restart-all" && request.method === "POST") {
        // ä½¿ç”¨ ctx.waitUntil ç¡®ä¿é‡å¯é€»è¾‘åœ¨å“åº”è¿”å›åç»§ç»­æ‰§è¡Œï¼ˆé¿å…è¶…æ—¶ï¼‰
        ctx.waitUntil(
          restartAllApps().then(results => {
            console.log("[restart-all-api] æ‰‹åŠ¨é‡å¯æ‰€æœ‰åº”ç”¨ç»“æœ:", results);
          }).catch(error => {
            console.error("[restart-all-api] æ‰‹åŠ¨é‡å¯æ‰€æœ‰åº”ç”¨å‡ºé”™:", error.message);
          })
        );
        // ç«‹å³è¿”å›å“åº”ï¼ˆé¿å…å‰ç«¯ç­‰å¾…è¶…æ—¶ï¼‰
        return json({ 
          ok: true, 
          msg: "æ‰€æœ‰åº”ç”¨é‡å¯ä»»åŠ¡å·²å¯åŠ¨ï¼Œç»“æœå°†é€šè¿‡Telegramé€šçŸ¥" 
        });
      }
      
      // æ‰‹åŠ¨å¯åŠ¨ç«¯ç‚¹ï¼ˆåŸæœ‰åŠŸèƒ½ä¿ç•™ï¼‰
      if (url.pathname === "/start") {
        ctx.waitUntil(monitorAllApps("manual").then(results => {
          console.log("æ‰‹åŠ¨å¯åŠ¨ç»“æœ:", results);
        }));
        return json({ ok: true, msg: "æ‰‹åŠ¨å¯åŠ¨æ‰€æœ‰åº”ç”¨è¯·æ±‚å·²è§¦å‘" });
      }
      
      // åº”ç”¨çŠ¶æ€æ£€æŸ¥ç«¯ç‚¹ï¼ˆåŸæœ‰åŠŸèƒ½ä¿ç•™ï¼‰
      if (url.pathname === "/status") {
        const statusResults = [];
        
        for (const app of MONITORED_APPS) {
          const isHealthy = await checkAppUrl(app.url);
          statusResults.push({
            app: app.name,
            url: app.url,
            healthy: isHealthy,
            region: detectRegionFromUrl(app.url)
          });
        }
        
        return json({
          ok: true,
          apps: statusResults,
          timestamp: new Date().toISOString()
        });
      }
      
      // è¯Šæ–­ç«¯ç‚¹ï¼ˆåŸæœ‰åŠŸèƒ½ä¿ç•™ï¼‰
      if (url.pathname === "/check") {
        return json({
          ok: true,
          monitoredApps: MONITORED_APPS,
          regions: Object.keys(REGIONS),
          timestamp: new Date().toISOString()
        });
      }
      
      // é»˜è®¤å“åº”ï¼ˆåŸæœ‰åŠŸèƒ½ä¿ç•™ï¼‰
      return new Response("Cloud Foundry å¤šåº”ç”¨è‡ªåŠ¨ä¿æ´» Worker è¿è¡Œä¸­");
      
    } catch (error) {
      console.error("[error]", error?.message || error);
      return json({ ok: false, error: String(error) }, 500);
    }
  },

  // å®šæ—¶ä»»åŠ¡å¤„ç†ï¼ˆåŸæœ‰åŠŸèƒ½ä¿ç•™ï¼‰
  async scheduled(event, env, ctx) {
    try {
      email = env.EMAIL || email;
      password = env.PASSWORD || password;
      CHAT_ID = env.CHAT_ID || CHAT_ID;
      BOT_TOKEN = env.BOT_TOKEN || BOT_TOKEN;
      
      // ä½¿ç”¨ctx.waitUntilç¡®ä¿å®šæ—¶ä»»åŠ¡å®Œæˆ
      ctx.waitUntil(monitorAllApps("cron").then(results => {
        console.log("å®šæ—¶ä»»åŠ¡ç»“æœ:", results);
      }));
    } catch (error) {
      console.error("[cron-error]", error?.message || error);
    }
  }
};
